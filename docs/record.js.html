<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: record.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: record.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/*
 * seqJS
 * https://github.com/haydnKing/seqJS
 *
 * Copyright (c) 2014 Haydn King
 * Licensed under the MIT license.
 */

/**
 * @namespace
 */
var seqJS = seqJS || {};

(function(){

    /*
     * record object
     */
    var DEF_ANNOTATIONS = {
        "accession": "",
        "data_division": "",
        "date": "",
        "organism": "",
        "source": "",
        "taxonomy": [],
        "references": []
    };

    /**
     * Record object. Stores a biological sequence record.
     * @constructor
     * @param {seqJS.Seq} seq the sequence object
     * @param {string} id the record's id
     * @param {string} name the record's name
     * @param {string} desc the record's description
     * @param {Object} annotations the record's annotations in {key: value, ...} form
     */
    seqJS.Record = function(seq, id, name, desc, annotations){
        if(! seq instanceof seqJS.Seq){
            throw("seq must be a seqJS.Seq instance");
        }
        /** The sequence object */
        this.seq = seq;
        /** The record id */
        this.id = id || 0;
        /** The record name */
        this.name = name || "unnamed";
        /** The record description */
        this.desc = desc || "";
        
        annotations = annotations || {};
        for (var attr in DEF_ANNOTATIONS) { 
            annotations[attr] = annotations[attr] || DEF_ANNOTATIONS[attr]; 
        }

        /** Get or set an annotation if value is provided
         * @param {string} key annotation key
         * @param {string} [value] the new annotation value
         *
         * @return {string|seqJS.Record} return the annotation if no value was
         * given or this if a value is given
         */
        this.annotation = function(k, v) {
            if(k === undefined){
                throw "Record::annotation(k,v): key is required";
            }
            if(v === undefined){
                return annotations[k];
            }
            else {
                annotations[k] = v;
                return this;
            }
        };

        /** List the record's annotations
         * @returns {Array} an array of annotations
         */
        this.listAnnotations = function() {
            var ret = [], p;
            for(p in annotations){
                ret.push(p);
            }
            return ret;            
        };

        /** Remove an annotation
         * @returns {seqJS.Record} returns this
         */
        this.clearAnnotation = function(k) {
            annotations[k] = undefined;
            return this;
        };

        /** Get sequence length, an alias for this.seq.length()
         * @returns {Number} the number of nucleotides in the sequence
         */
        this.length = function() {
            return this.seq.length();
        };
    };

    /*
     * Seq object
     */

    /** Array of possible alphabets as strings
     * @constant {Array(string)} seqJS.Alphabets
     */
    seqJS.Alphabets = ['DNA','aDNA','RNA','aRNA','PROT','aPROT'];
    /** Dictionary of regular expressions which sequences of each alphabet
     * should match
     * @constant {Object} seqJS.Alphabets_RE
     */
    seqJS.Alphabets_RE = {
        DNA: /^[ACGT]+$/,
        aDNA: /^[ACGTRYSWKMBDHVN]+$/,
        RNA: /^[ACGU]+$/,
        aRNA: /^[ACGURYSWKMBDHVN]+$/,
        PROT: /^[ACDEFGHIKLMNPQRSTVWY]+$/,
        aPROT: /^[ACDEFGHIKLMNPQRSTVWYBXZ]+$/
    };
    /** An object representing a biological sequence
     * @constructor
     * @param {string} _seq the sequence as a string
     * @param {string} _alphabet the alphabet, one of {@link seqJS.Alphabets}
     * @param {Array} [_features=new Array()] an array of {@link seqJS.Feature} objects referring to
     * the sequence
     * @param {string} [_topology='linear'] sequence topology, 'linear' or
     * 'circular'
     * @param {string} [_length_unit=taken from alphabet] the length unit of
     * the sequence, one of 'bp', 'aa' or 'rc'
     * @param {string} [_strand_type=''] type of strand, e.g. 'ss', 'ds'.
     * default is '' - unknown
     * @param {string} [_residue_type=''] type of each residue e.g. 'DNA',
     * 'RNA'
     */
    seqJS.Seq = function(_seq, _alphabet, _features, _topology, _length_unit, _strand_type, _residue_type){
        if(_seq === undefined) { throw 'Argument seq is required';}
        if(_alphabet === undefined) { throw 'Argument alphabet is required';}
        _features = _features || [];
        _topology = _topology || "linear";
        if(['linear','circular'].indexOf(_topology) &lt; 0){
            throw 'topology must be \'linear\' or \'circular\'';
        }
        _length_unit = _length_unit || ((_alphabet.indexOf('PROT') >= 0) ? 
            'aa' : 'bp');
        _residue_type= _residue_type || '';
        _strand_type = _strand_type || '';

        var test_st = function(st){
            if(['ss','ds','ms',''].indexOf(st) &lt; 0){
                throw 'Strand type must be \'ss\', \'ds\', or \'ms\', not \''+st+'\'';
            }
        };
        var test_lu = function(lu){
            if(['bp', 'aa', 'rc'].indexOf(lu) &lt; 0){
                throw 'Length unit must be \'bp\', \'aa\', or \'rc\', not \''+lu+'\'';
            }
        };

        test_st(_strand_type);
        test_lu(_length_unit);

        _seq = _seq.toUpperCase();
        if(seqJS.Alphabets.indexOf(_alphabet) &lt; 0){
            throw "Invalid Alphabet";
        }
        /** Get the sequence
         * @returns {string} the raw sequence
         */
        this.seq = function() {return _seq;};
        /** Get the sequence length (this.seq().length)
         * @returns {number} sequence length
         */
        this.length = function() {return _seq.length;};
        /** Get the sequence alphabet
         * @returns {string} sequence alphabet, one of {@link seqJS.Alphabets}
         */
        this.alphabet = function() {return _alphabet;};
        /** Get the list of features
         * @returns {Array} an array of {@link SeqJS.Feature} objects
         */
        this.features = function() {return _features;};
        /** Get the length unit
         * @return {string} length unit ('bp','aa','rc')
         */
        this.lengthUnit = function(v) {
            if(v === undefined){
                return _length_unit;
            }
            test_lu(v);
            _length_unit = v;
            return this;
        };
        /** Get the residue type
         * @returns {string} residue type ('DNA', 'RNA', etc)
         */
        this.residueType = function(v) {
            if(v === undefined){
                return _residue_type;
            }
            _residue_type = v;
            return this;
        };
        /** Get the strand type
         * @returns {string} strand type ('ss','ds','')
         */
        this.strandType = function(v) {
            if(v === undefined){
                return _strand_type;
            }
            test_st(v);
            _strand_type = v;
            return this;
        };
        /** Get the topology of the molecule
         * @returns {string} either 'linear' or 'circular'
         */
        this.topology = function() {
            return _topology;
        };
        /** Set the topology to 'linear'
         * @returns {seqJS.Seq} this
         */
        this.linearize = function() {
            _topology = 'linear';
            return this;
        };
        /** Set the topology to 'circular'
         * @returns {seqJs.Seq} this
         */
        this.circularize = function() {
            _topology = 'circular';
            return this;
        };
    };

    var loc_fmt = /(?:^([&lt;>]?)(\d+)$)|(?:^(\d+)\.(\d+)$)/;
 
    /** Represent a single location as either and exact base (''), before a
     *  specific base ('&lt;'), after a specific base ('>') or between two specific
     *  bases ('A.B')
     * @constructor
     * @param {string|number} _location Either a string defining a location to
     * be parsed or the position of the location
     * @param {string} [_operator] The operator which applies, either '', '&lt;', 
     * '.', or '>'. If this parameter is given, then _location must be an 
     * integer. If _operator is given as '.', then _location2 is required
     * @param {number} [_location2] The second location, used only when
     * representing locations which are between two points, e.g 100.200
     */   
    seqJS.Location = function(_location, _operator, _location2) {
        var self = this;
        if (typeof _location === 'string' || _location instanceof String){
            var m = loc_fmt.exec(_location);
            if(m===null){
                throw "Badly formated location \'"+_location+"\'";
            }
            if(m[1] !== undefined){
                _operator = m[1] || '';
                _location = parseInt(m[2],10);
            }
            else{
                _location = parseInt(m[3],10);
                _operator = '.';
                _location2= parseInt(m[4],10);
            }
        }
        _operator = _operator || '';
        if(['', '&lt;', '>', '.'].indexOf(_operator) === -1){
            throw "Invalid location operator \'" + _operator + "\'";
        }
        if(_location &lt; 1){
            throw "Invalid location \'" + _location + "\'";
        }
        if(_operator === '.'){
            if(_location2 === undefined){
                throw "Must have two locations for '.' operator";
            }
            if(_location2 &lt; _location){
                throw "Second location must be less than the first";
            }
        }
        else{
            if(_location2 !== undefined){
                throw "Only 1 location required for '"+_operator+"'";
            }
        }
        /** Get the first location
         * @returns {number} The first location - equal to the exact location
         * if operator is ''
         */
        this.location = function() {return _location;};
        /** Get the second location. This is only defined if operator is '.'
         * @returns {number|undefined} returns the second location if operator
         * is '.'
         */
        this.location2= function() {return _location2;};
        /** Get the operator
         * @returns {string} either '', '&lt;', '>' or '.'
         */
        this.operator = function() {return _operator;};

        /** Is the location less than rhs
         * @param {seqJS.Location} rhs the location to compare with
         * @returns {boolean} true if rhs is strictly smaller than this
         */
        this.lt = function(rhs) {return !self.ge(rhs);};
        /** Is the location greater than rhs
         * @param {seqJS.Location} rhs the location to compare with
         * @returns {boolean} true if rhs is greater than this
         */
        this.gt = function(rhs) {
            if(rhs.operator() === '.'){
                return _location > rhs.location2();
            }
            return _location > rhs.location();
        };

        /** Get a genbank style string representation
         * @returns {string} 
         */
        this.toString = function() {
            if(_operator === '.'){
                return _location + '.' + _location2;
            }
            return _operator + _location;
        };
    };

    var span_fmt = /(\S+)\.\.(\S+)/;
    /** Represent a span between two locations. By definition 
     *  location1 &lt; location 2.
     *  @constructor 
     *  @param {string|seqJS.Location} _location1 the first location
     *  @param {string|seqJS.Location} _location2 the second location
     *  @param {boolean} complement true if the span is on the reverse strand
     */
    seqJS.Span = function(_location1, _location2, complement){
        var self = this;
        complement = complement || false;
        //if we're given a string
        if(typeof _location1 === 'string' || _location1 instanceof String){
            var m = span_fmt.exec(_location1);
            if(m===null){
                throw "Malformed location string \'"+_location1+"\'";
            }
            _location1 = new seqJS.Location(m[1]);
            _location2 = new seqJS.Location(m[2]);
        }

        //if we're given numbers then implicit exact
        if(typeof _location1 === 'number' && typeof _location2 === 'number'){
            _location1 = new seqJS.Location(_location1);
            _location2 = new seqJS.Location(_location2);
        }

        if(_location1.gt(_location2)){
            throw "First location is greater than the second";
        }


        /** Get the first location
         * @returns {seqJS.Location} The first (smallest) location
         */
        this.location1 = function() {return _location1;};
        /** Get the second location
         * @returns {seqJS.Location} The second (largest) location
         */
        this.location2 = function() {return _location2;};

        /** Does this span overlap with another span
         * @param {seqJS.Span} rhs the other span
         * @returns {boolean} true if the spans overlap
         */
        this.overlaps = function(rhs) {
            if(_location1.lt(rhs.location1()) &&
               _location2.gt(rhs.location1())) {
                return true;
            }
            if(_location1.lt(rhs.location2()) &&
               _location2.gt(rhs.location2())) {
                return true;
            }
            if(_location1.gt(rhs.location1()) &&
               _location2.lt(rhs.location2())) {
                return true;
            }
            return false;
        };    

        /** Get a genbank style string representation
         * @returns {string} genbank style string (e.g. 100..200)
         */
        this.toString = function() {
            return _location1.toString() + '..' + _location2.toString();
        };

        /** Returns true if the span is on the reverse strand
         * @returns {boolean} true if we're on the reverse strand
         */
        this.isComplement = function() {
            return complement;
        };
        /** Set the value of the complement flag
         * @param {boolean} value The new complement value
         * @returns {seqJS.Span} this
         */
        this.setComplement = function(value) {
            complement = value;
            return this;
        };

        /** Get all spans -- in this case an array containing this
         * @return {Array(seqJS.Span)} an array of one
         */
        this.getSpans = function() {
            return new Array(self);
        };

        /** Is the object a span?
         * @returns {boolean} true
         */
        this.isSpan = function() {return true;};
    };

    /*
     * LocationOperator:
     *  store a Span or several spans and an operator which affects those spans
     *  such as join(...), order(...) or complement()
     */

    var operator_fmt = /^(complement|join|order)\((.+)\)$/;
    /*
     * tokenize:
     *  split string arguments on commas, paying attention to the depth of
     *  parentheses, i.e. 'a,b,c(d,e,f),g' -> ['a', 'b', 'c(d,e,f)', 'g']
     */
    var tokenize = function(string){
        var ret = [], items = string.split(',');
        var depth = 0, current = '';
        for(var i = 0; i &lt; items.length; i++){
            if(current){
                current = current + ',' + items[i];
            }
            else{
                current = items[i];
            }
            depth = - (current.split('(').length - 1) + (current.split(')').length -1 );
            if(depth === 0){
                ret.push(current.trim());
                current = '';
            }
        }
        if(depth > 0){
            throw "Unmatched parentheses in \'"+string+"\'";
        }
        return ret;
    };

    /** Stores an operator like 'complement', 'join' or 'order' and the span(s)
     * on which they operate
     * @constructor
     * @param {string} location the location string to parse
     * @param {string} [prev_op] the previous operator, used to catch errors
     * where joins and complements are both used
     */
    seqJS.LocationOperator = function(location, prev_op){
        var items = [], operator = '';

        var m = operator_fmt.exec(location);
        if(m){
            operator = m[1];
            switch(operator){
                case 'complement':
                    items.push(new seqJS.LocationOperator(m[2].trim()));
                    break;
                case 'join':
                case 'order':
                    //check whether we're duplicating
                    if(prev_op !== undefined && operator !== prev_op){
                        throw "Location lines cannot mix join(...) and order(...)";
                    }
                    var s_items = tokenize(m[2]);
                    for(var i = 0; i &lt; s_items.length; i++){
                        items.push(new seqJS.LocationOperator(s_items[i], operator));
                    }
            }
        }
        else {
            items.push(new seqJS.Span(location));
        }

        /** Convert to a genbank style string
         * @returns {string} string representation
         */
        this.toString = function() {
            var s = [];
            for(var i = 0; i &lt; items.length; i++){
                s.push(items[i].toString());
            }
            if(operator){
                return operator + '(' + s.join(',') + ')';
            }
            return s[0];
        };
        
        /** Called by an outer FeatureOperator to set whether this should be
         * a complement or not
         * @param {boolean} value Whether or not spans should be on the reverse
         * strand
         */
        this.setComplement = function(value){
            value = value || false;
            if(operator === 'complement'){
                value = !value;
            }
            for(var i = 0; i &lt; items.length; i++){
                items[i].setComplement(value);
            }
        };

        /** Get a list of all spans in the correct order
         * @returns {Array(seqJS.Span)} 
         */
        this.getSpans = function(){
            var spans = [], i;
            if(operator === 'complement'){
                for(i = items.length-1; i >= 0; i--){
                    spans = spans.concat(items[i].getSpans().reverse());
                }
            }
            else{
                for(i = 0; i &lt; items.length; i++){
                    spans = spans.concat(items[i].getSpans());
                }
            }
            return spans;
        };

        /** Get the operation used to merge spans
         * @returns {string} 'join' or 'order'
         */
        this.getMergeOperator = function() {
            var op;
            if(prev_op) {
                return prev_op;
            }
            else {
                for(var i = 0; i &lt; items.length; i++){
                    if(!items[i].isSpan()){
                        op = items[i].getMergeOperator();
                        if(op){
                            return op;
                        }
                    }
                }
            }
            return '';
        };

        /** Test if the object is a span
         * @returns {boolean} false
         */
        this.isSpan = function() {return false;};

    };



    /**
     * FeatureLocation
     *  Store base LocationOperator and procide access to the underlying data
     *  (somehow)
     * @constructor
     * @param {seqJS.FeatureLocation} location the location of the feature
     */
    seqJS.FeatureLocation = function(location){
        var loc;
        try{
            loc = new seqJS.LocationOperator(location);
        }
        catch(e){
            throw e + " while parsing location string \'"+location+"\'";
        }
        //set complement flags on Spans
        loc.setComplement();

        this.toString = function(){
            return loc.toString();
        };

        this.getSpans = function() {
            return loc.getSpans();
        };

        this.getMergeOperator = function() {
            return loc.getMergeOperator();
        };
    };
    
    /**  Store information about a feature
     *      - type: the feature type -- gene, CDS, etc.
     *      - location: feature location -- either a FeatureLocation object or
     *          string from which one will be built
     *      - qualifiers: dictionary Object of qualifiers to be stored with the
     *          feature
     *
     * @constructor
     * @param {string} _type the Feature type (e.g. 'gene', 'CDS', ...)
     * @param {seqJS.FeatureLocation|string} _location The feature's location, either
     * as a string in genbank format (e.g. 1..50) or a 
     * {@link seqJS.FeatureLocation} object
     */
    seqJS.Feature = function(_type, _location, _qualifiers){
        var self = this;

        if(_type === undefined){
            throw "Features cannot be constructed without a type";
        }
        if(_location === undefined){
            throw "Features must have a location";
        }

        if(typeof _location === 'string' || _location instanceof String){
            _location = new seqJS.FeatureLocation(_location);
        }

        
        var qualifiers = {};
        var q_keys = [];
        var init = function() {
            if(_qualifiers){
                for(var k in _qualifiers){
                    self.qualifier(k, _qualifiers[k]);
                }
            }
        };


        /** Get or set the feature type
         * @param {string} [new_type] if given, this is the new type
         * @returns {string|seqJS.Feature} return the type if there are no
         * arguments or this if a new_type is given
         */
        this.type = function(new_type) {
            if(new_type){
                _type = new_type;
                return self;
            }
            return _type;
        };

        /** Get or set the location
         * @param {string|seqJS.FeatureLocation} [new_location] If given, this
         * is the new location
         * @returns {seqJS.FeatureLocation|seqJS.Feature} returns this if a
         * new_location is given, otherwise returns the location
         */
        this.location = function(new_location){
            if(new_location){
                if(typeof new_location === 'string' || 
                                    new_location instanceof String){
                    _location = new seqJS.FeatureLocation(new_location);
                }
                else {
                    _location = new_location;
                }
                return self;
            }
            return _location;
        };

        /** Get or set a feature qualifier
         * @param {string} key The qualifier name
         * @param {string} [value] The new qualifier value
         * @returns {seqJS.Feature|string} return the qualifier value if no
         * value is give, otherwise return this
         */
        this.qualifier = function(key, value) {
            if(key === undefined){
                throw "Key must be defined";
            }
            if(value === undefined){
                return qualifiers[key];
            }
            else{
                if(q_keys.indexOf(key) &lt; 0){
                    q_keys.push(key);
                }
                qualifiers[key] = value;
                return self;
            }
        };

        /** Remove a feature qualifier
         * @param {string|Array(string)} [to_remove] the qualifier (or qualifiers
         * if an Array) to remove. Removes all qualifiers if to_remove is
         * omitted
         * @returns {seqJS.Feature} this
         */
        this.clearQualifiers = function(to_remove){
            var idx;
            if(to_remove === undefined){
                q_keys = [];
                qualifiers = {};
            }
            else if(to_remove instanceof Array){
                for(var i = 0; i &lt; to_remove.length; i++){
                    qualifiers[to_remove[i]] = undefined;
                    idx = q_keys.indexOf(to_remove[i]);
                    if(idx > -1){
                        q_keys.splice(idx, 1);
                    }
                }
            }
            else {
                qualifiers[to_remove] = undefined;
                idx = q_keys.indexOf(to_remove);
                if(idx > -1){
                    q_keys.splice(idx, 1);
                }
            }
            return this;
        };

        /** Get an array of all qualifiers
         * @returns {Array(string)} an Array of qualifier keys
         */
        this.qualifierKeys = function() {
            return q_keys;
        };

        init();
    };


}());
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="seqJS.Feature.html">Feature</a></li><li><a href="seqJS.FeatureLocation.html">FeatureLocation</a></li><li><a href="seqJS.Location.html">Location</a></li><li><a href="seqJS.LocationOperator.html">LocationOperator</a></li><li><a href="seqJS.Record.html">Record</a></li><li><a href="seqJS.Seq.html">Seq</a></li><li><a href="seqJS.Span.html">Span</a></li></ul><h3>Namespaces</h3><ul><li><a href="seqJS.html">seqJS</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.2</a> on Wed Jun 11 2014 15:04:14 GMT+0100 (BST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
